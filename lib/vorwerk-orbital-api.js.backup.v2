'use strict';

const https = require('https');
const ORBITAL_HOST = 'orbital.ksecosys.com';

class VorwerkOrbitalClient {
    constructor() {
        this.token = null;
    }

    setToken(token) {
        this.token = token;
    }

    _request(hostname, method, path, data, callback) {
        const options = {
            hostname: hostname,
            path: path,
            method: method,
            headers: {
                'Authorization': 'Auth0Bearer ' + this.token,
                'Accept': 'application/vnd.neato.orbital-http.v1+json',
                'Content-Type': 'application/json',
                'User-Agent': 'MyKobold/3.12.0'
            }
        };

        if (data) {
            const body = JSON.stringify(data);
            options.headers['Content-Length'] = Buffer.byteLength(body);
        }

        const req = https.request(options, (res) => {
            let body = '';
            
            res.on('data', (chunk) => {
                body += chunk;
            });
            
            res.on('end', () => {
                console.log('[VorwerkVR7] API', method, path, '- Status:', res.statusCode);
                
                try {
                    const json = body ? JSON.parse(body) : {};
                    
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                        callback(null, json);
                    } else {
                        console.log('[VorwerkVR7] Error:', json);
                        // 204 No Content ist OK
                        if (res.statusCode === 204) {
                            callback(null, {});
                        } else {
                            callback(new Error(`API Error: ${res.statusCode}`), json);
                        }
                    }
                } catch (e) {
                    // Leere Response bei 204/200 ist OK
                    if (res.statusCode === 204 || (res.statusCode === 200 && !body)) {
                        callback(null, {});
                    } else {
                        console.log('[VorwerkVR7] Parse error:', e.message);
                        callback(e, body);
                    }
                }
            });
        });

        req.on('error', (e) => {
            console.log('[VorwerkVR7] Request error:', e.message);
            callback(e);
        });

        if (data) {
            req.write(JSON.stringify(data));
        }

        req.end();
    }

    getRobots(callback) {
        this._request(ORBITAL_HOST, 'GET', '/users/me/robots', null, (error, data) => {
            if (error) {
                return callback(error);
            }
            this._processRobots(data, callback);
        });
    }

    _processRobots(data, callback) {
        if (!data || !Array.isArray(data)) {
            console.log('[VorwerkVR7] Invalid robot data');
            return callback(null, []);
        }

        console.log('[VorwerkVR7] Found', data.length, 'robot(s)');

        const robots = data.filter(r => {
            const modelName = r.model_name || r.model || '';
            const vendor = r.vendor || '';
            return modelName.includes('VR') || vendor === '3' || vendor === 3;
        }).map(robotData => new VorwerkVR7Robot(robotData, this));
        
        callback(null, robots);
    }
}

class VorwerkVR7Robot {
    constructor(data, client) {
        this._data = data;
        this._client = client;
        
        this.name = data.name || 'VR7';
        this._serial = data.serial || data.serialNo;
        this._robotId = data.id;
        this._model = data.model_name || 'VRXX';
        
        console.log('[VorwerkVR7] Robot:', this.name, 'ID:', this._robotId);
        
        // Status - wird von getState() aktualisiert
        this.state = 1; // idle
        this.charge = 50; // Default
        this.isDocked = true;
        this.isCharging = false;
        this.eco = false;
        this.noGoLines = true;
        
        this._floorplanUuid = '2725adb9-9838-42ce-bdd0-12cf62a58165';
        
        this.canStart = true;
        this.canResume = false;
        this.canPause = false;
        this.canGoToBase = true;
        this.dockHasBeenSeen = true;
    }

    getState(callback) {
        console.log('[VorwerkVR7] Getting cleaning history for state...');
        
        // KORREKTER ENDPOINT: /robots/{id}/cleanings (zeigt letzten Status)
        this._client._request(ORBITAL_HOST, 'GET', `/robots/${this._robotId}/cleanings`, null, (error, data) => {
            if (error) {
                console.log('[VorwerkVR7] Error getting cleanings:', error.message);
                return callback(error);
            }

            if (data && Array.isArray(data) && data.length > 0) {
                const lastCleaning = data[0];
                console.log('[VorwerkVR7] Last cleaning:', JSON.stringify(lastCleaning));
                
                // Parse state from last cleaning
                if (lastCleaning.runs && lastCleaning.runs.length > 0) {
                    const run = lastCleaning.runs[0];
                    const runState = run.state;
                    
                    console.log('[VorwerkVR7] Run state:', runState);
                    
                    // State mapping
                    const stateMap = {
                        'idle': 1,
                        'paused': 3,
                        'cleaning': 2,
                        'done': 1,
                        'error': 4
                    };
                    
                    this.state = stateMap[runState] || 1;
                    this.canStart = (runState === 'idle' || runState === 'done');
                    this.canPause = (runState === 'cleaning');
                    this.canResume = (runState === 'paused');
                    
                    console.log('[VorwerkVR7] State:', this.state, 'canStart:', this.canStart, 'canPause:', this.canPause);
                }
            }

            callback(null, data);
        });
    }

    startCleaning(eco, navigationMode, noGoLines, callback) {
        console.log('[VorwerkVR7] START cleaning - eco:', eco, 'noGoLines:', noGoLines);
        
        const command = {
            runs: [{
                map: {
                    floorplan_uuid: this._floorplanUuid,
                    zone_uuid: null,
                    nogo_enabled: noGoLines
                },
                settings: {
                    mode: eco ? 'eco' : 'auto',
                    navigation_mode: 'normal'
                }
            }]
        };

        console.log('[VorwerkVR7] Command:', JSON.stringify(command));

        this._client._request(ORBITAL_HOST, 'POST', `/robots/${this._robotId}/cleaning/v2`, command, (error, result) => {
            if (!error) {
                console.log('[VorwerkVR7] ✓ Cleaning started');
                this.state = 2;
                this.canPause = true;
                this.canStart = false;
            }
            callback(error, result);
        });
    }

    pauseCleaning(callback) {
        console.log('[VorwerkVR7] PAUSE cleaning');
        
        // KORREKTER ENDPOINT: PUT /robots/{id}/cleaning/pause
        this._client._request(ORBITAL_HOST, 'PUT', `/robots/${this._robotId}/cleaning/pause`, {}, (error, result) => {
            if (!error) {
                console.log('[VorwerkVR7] ✓ Paused');
                this.state = 3;
                this.canResume = true;
                this.canPause = false;
            } else {
                console.log('[VorwerkVR7] Pause error:', error.message);
            }
            callback(error, result);
        });
    }

    resumeCleaning(callback) {
        console.log('[VorwerkVR7] RESUME cleaning');
        
        // KORREKTER ENDPOINT: PUT /robots/{id}/cleaning/resume
        this._client._request(ORBITAL_HOST, 'PUT', `/robots/${this._robotId}/cleaning/resume`, {}, (error, result) => {
            if (!error) {
                console.log('[VorwerkVR7] ✓ Resumed');
                this.state = 2;
                this.canPause = true;
                this.canResume = false;
            } else {
                console.log('[VorwerkVR7] Resume error:', error.message);
            }
            callback(error, result);
        });
    }

    sendToBase(callback) {
        console.log('[VorwerkVR7] SEND TO BASE');
        
        // KORREKTER ENDPOINT: PUT /robots/{id}/cleaning/stop
        this._client._request(ORBITAL_HOST, 'PUT', `/robots/${this._robotId}/cleaning/stop`, {}, (error, result) => {
            if (!error) {
                console.log('[VorwerkVR7] ✓ Stopped, returning to base');
                this.state = 1;
            } else {
                console.log('[VorwerkVR7] Stop error:', error.message);
            }
            callback(error, result);
        });
    }

    startSpotCleaning(eco, width, height, repeat, navigationMode, callback) {
        console.log('[VorwerkVR7] SPOT cleaning');
        
        const command = {
            runs: [{
                map: {
                    floorplan_uuid: this._floorplanUuid,
                    spot_cleaning: {
                        width: width || 200,
                        height: height || 200
                    }
                },
                settings: {
                    mode: eco ? 'eco' : 'auto',
                    navigation_mode: 'normal'
                }
            }]
        };

        this._client._request(ORBITAL_HOST, 'POST', `/robots/${this._robotId}/cleaning/v2`, command, callback);
    }

    enableSchedule(callback) {
        callback(new Error('Not implemented'));
    }

    disableSchedule(callback) {
        callback(new Error('Not implemented'));
    }
}

module.exports = {
    Client: VorwerkOrbitalClient,
    Robot: VorwerkVR7Robot
};
